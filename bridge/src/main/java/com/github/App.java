package com.github;

/**
 * 桥接模式
 * 将抽象部分与它的实现部分分离，使它们都可以独立地变化。
 * 当一个抽象可能有多个实现时，通常用继承来协调它们。抽象类定义对该抽象的接口， 而具体的子类则用不同方式加以实现。
 * 但是此方法有时不够灵活。继承机制将抽象部分与它的实现部分固定在一起，使得难以对抽象部分和实现部分独立地进行修改、扩充和重用。
 *
 * 适用性 以下一些情况使用Bridge模式:
 * •  你不希望在抽象和它的实现部分之间有一个固定的绑定关系。 例如这种情况可能是因为， 在程序运行时刻实现部分应可以被选择或者切换。
 * •  类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge 模式使你 可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。
 * •  对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。
 * •  （ C + + ）你想对客户完全隐藏抽象的实现部分。在 C + + 中，类的表示在类接口中是可见的。
 * •  正如在意图一节的第一个类图中所示的那样，有许多类要生成。这样一种类层次结构说 明你必须将一个对象分解成两个部分。Rumbaugh 称这种类层次结构为“嵌套的普化” （nested generalizations ） 。
 * •  你想在多个对象间共享实现（可能使用引用计数） ，但同时要求客户并不知道这一点。 一个简单的例子便是Coplien的String 类 [Cop92] ，在这个类中多个对象可以共享同一个字 符串表示（StringRep） 。
 *
 * 适配器模式和桥接模式不同点：
 *  1）适配器：改变已有的两个接口，让他们相容。
 *  2）桥接模式：分离抽象化和实现，使两者的接口可以不同，目的是分离。
 *   桥接是先有桥，才有两端的东西
 *   适配是先有两边的东西，才有适配器
 */
public class App {

    public static void main(String[] args) {
        Abstraction abstraction = new RefinedAbstraction(new ConcreteImplementor());
        abstraction.doSomething();
    }
}
