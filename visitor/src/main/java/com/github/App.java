package com.github;

/**
 * 1.意图
 * 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提
 * 下定义作用于这些元素的新操作。
 * 2.动机
 * 考虑一个编译器，它将源程序表示为一个抽象语法树。该编译器需在抽象语法树上实施
 * 某些操作以进行“静态语义”分析，例如检查是否所有的变量都已经被定义了。它也需要生
 * 成代码。因此它可能要定义许多操作以进行类型检查、代码优化、流程分析，检查变量是否
 * 在使用前被赋初值，等等。此外，还可使用抽象语法树进行优美格式打印、程序重构、code
 * instrumentation以及对程序进行多种度量。
 * <p>
 * 下面是访问者模式的一些优缺点：
 * 1)访问者模式使得易于增加新的操作访问者使得增加依赖于复杂对象结构的构件的操
 * 作变得容易了。仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。相反，
 * 如果每个功能都分散在多个类之上的话，定义新的操作时必须修改每一类。
 * 2)访问者集中相关的操作而分离无关的操作相关的行为不是分布在定义该对象结构的
 * 各个类上，而是集中在一个访问者中。无关行为却被分别放在它们各自的访问者子类中。这
 * 就既简化了这些元素的类，也简化了在这些访问者中定义的算法。所有与它的算法相关的数
 * 据结构都可以被隐藏在访问者中。
 * 3)增加新的ConcreteElement类很困难Visitor模式使得难以增加新的Element的子类。每
 * 添加一个新的ConcreteElement都要在Vistor中添加一个新的抽象操作，并在每一个
 * ConcretVisitor类中实现相应的操作。有时可以在Visitor中提供一个缺省的实现，这一实现可
 * 以被大多数的ConcreteVisitor继承，但这与其说是一个规律还不如说是一种例外。
 * 所以在应用访问者模式时考虑关键的问题是系统的哪个部分会经常变化，是作用于对象
 * 结构上的算法呢还是构成该结构的各个对象的类。如果老是有新的ConcretElement类加入进来
 * 的话，Vistor类层次将变得难以维护。在这种情况下，直接在构成该结构的类中定义这些操作
 * 可能更容易一些。如果Element类层次是稳定的，而你不断地增加操作获修改算法，访问者模
 * 式可以帮助你管理这些改动
 */
public class App {

    public static void main(String[] args) {
        ObjectStructure objectStructure = new ObjectStructure();
        objectStructure.accept(new ConcreteVisitor1());
        objectStructure.accept(new ConcreteVisitor2());
    }

}
